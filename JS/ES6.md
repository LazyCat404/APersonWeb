# 前端都要会的

### let 与 const [关键字]

> ES6 明确规定，代码块内如果存在 `le`t 或者 `const`，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。

#### let

1. `let` 声明的变量只在 `let` 所在的代码块内有效（用法上和 `var`类似）

```js
{
    let a = 0;  //如果 用 var 声明，则下边并不会报错
    console.log(a); //打印a
}
console.log(a); //报错，变量未生名
```
2. `let`只能声明一次（多声明会报错），`var`可以声明多次

> 注意：如果一个变量先用`var`声明过，在用`let`声明也是会报错的；同样，先用`let`声明，再用`var`声明也是会报错的，也就是说，`let`声明的变量只能是未被声明过的。

3. `let` 不存在变量提升，`var` 会变量提升

> 可参考[基础进阶一](基础进阶一.md)的预编译部分，了解变量提升

```js
console.log(a);  //报错，变量未定义（未经声明就调用）
let a = "apple";

console.log(b);  //undefined，预编译环节，变量提升，所以并不会报错，但未进行赋值
var b = "banana"; 
```

>综合`let`声明变量的优点，在`for`循环语句中用`let`代替`var`可避免`bug`的出现

#### const 

1. `const` 声明一个只读的常量，一旦声明，常量的值就不能被改变（如果强行改变常量的值会报错）

> `const` 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（`number` 、`string` 、`boolean`）,值就保存在变量指向的那个内存地址，因此 `const` 声明的简单类型变量等同于常量。而复杂类型（`object` 、`array` 、`functio`n），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 `const` 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 `const` 声明复杂类型对象时要慎重。

### 解构赋值















### 字符串扩展

> 利用两个‘`’将字符串包裹

1. 语义化：支持换行，格式化HTML标签

2. 变量用`${变量}`包裹


#### 模板字符串

1. 更加语义化，可折行、换行