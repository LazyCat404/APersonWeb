# 已经在路上了，UP

### 继承

1. 传统形式 ==> 原型链 ==> 过多的继承了没用的属性

2. 借用构造函数 ==> 利用 call、apply 所以不算标准的继承模式

> this 放进去的前提，这个函数必须是 new 来的

    - 不能继承借用构造函数的原型

    - 每次构造函数都要多走一个函数 ==> 浪费效率

3. 共享原型（较好的继承方法）不能随便改动自己的原型（一定要先继承后使用）

> 共享原型是：`son.prototype = father.prototype`

```
Father.prototype.name = 'Miao';
function Father(){}
function Son(){}
function inherit(Target,Origin){ //继承方法封装
    Target.prototype = Origin.prototype; //两个原型指向相同，改其中一个，另一个也会改
}
inherit(Son,Father);
var son = new Son(); //继承后调用
```
4. 圣杯模式是在方法三的共有原型，但是在共有原型的基础上有改变。

> 圣杯模式是：另外加个构造函数 `function F(){}`当做中间层，然后让`F`和 `Father` 共有一个原型`F.prototype=Father.prototype`，然后 `Son.prototype = new F();`使用原型链形成了继承关系，现在改 `Son.prototype` 就不会影响 `Father.prototype`

```
//圣杯继承方法封装
function inherit(Target,Origin){ 
    function F(){
        F.prototype = Origin.prototype; //此行和下一行位置一定不能颠倒
        Target.prototype = new F();
        /**
            此时，son.constructor 指向了 function Father(){},应该指向 function Son(){}
            理解：son.__proto__ --> new F().__proto__ --> Father.prototype
        */
        Target.prototype.constructor = Target;
        Target.prototype.uber = Origin.prototype; //真正继承自谁

    }
}
```
#### 闭包：属性私有化

```
function  Person(name,age){
    var rAge = '30';  //这个就是私有属性
    this.name = name;
    this.age = age;
    this.realAge = function (){  //调用这个方法改变age属性
        this.age = rAge; 
    }
    this.sayAge = function (){ //可以通过调用方法，访问到私有属性
        console.log(rAge);  
    }
}
var person = new Person('yu','18');
/**
person.realAge() ==> 函数在外部调用（仍能访问到函数内部的值），形成闭包
*/
```
#### 圣杯模式高端写法（参考上边的闭包私有化属性思考）
```
var  inherit = (function (){    //立即执行函数
    var F = function (){};   //只用于过渡，设为私有属性
    return function (Target,Origin){
        F.prototype = Origin.prototype; 
        Target.prototype = new F();
        Target.prototype.constructor = Target;
        Target.prototype.uber = Origin.prototype; 
    }
}());
```






#### [上一篇：基础进阶一](基础进阶一.md)