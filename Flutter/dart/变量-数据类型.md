# 变量声明

## var

> 最灵活的变量声明方式，它会根据变量的初始值自动推断类型；（类型兼容的情况下）可以重新赋值。

```dart
// 变量声明
var a = 10;
var b = 20.5;
var c = 'hello';

// 类型推断
var x = 100; // 推断为 int
var y = 3.14; // 推断为 double
var z = 'Dart'; // 推断为 String

// 重新赋值
c = 'world'; // 重新赋值为 String
// c = 100; // 编译错误，类型不匹配
```

## const

> 用于声明**编译时常量**，其值必须在**编译时**确定（不能使用运行时计算的值）；一旦声明，值和引用都不能改变（不可重新赋值），支持类型推断。

```dart
// 声明（编译时）常量、类型推断
const x = 2 * 3; // 推断为 int
const y = 3.14; // 推断为 double
const z = 'Dart'; // 推断为 String
const a = [1,2,3]; // 推断为 List<int>

/**
  * 错误使用示例：
  * z = 'world'; // 编译错误，常量（值）不能重新赋值
  * a.add(4); // 编译错误，常量（引用）改变
  * const d = DateTime.now(); // 编译错误，DateTime.now() 是运行时值
  */
```

## final

> 用于声明**运行时常量**，其值可以在运行时确定，但只能赋值一次；支持类型推断。

```dart
// 声明（运行时）常量、类型推断
final x = 2 * 3; // 推断为 int
final y = 3.14; // 推断为 double
final z = 'Dart'; // 推断为 String
final a = [1,2,3]; // 推断为 List<int>
final d = DateTime.now(); // 运行时确定

// a = [4,5,6] // 编译错误，常量（值/引用）不能重新赋值
a.add(4)  // 合法：对象（引用）本身可以改变

// PS: final 声明的变量，引用本身不能改变（不能指向其他对象），但引用指向的对象内容可以改变（如果对象本身支持修改）
```

# 数据类型详解

> Dart 是一种强类型语言，具有静态类型检查和类型推断特性。本文档详细介绍 Dart 中的各种数据类型。

## 基本数据类型

### Number（数字）

> Dart 提供两种数字类型：`int` 和 `double`。

```dart
// 整数类型 (int)
int a = 30;
int b= 0xFFFF; // 十六进制表示

// 浮点数类型 (double)
double c = 3.14159;

// 使用num声明数字类型：int、double
num a = 10;
num b = 20.5;
```

### String（字符串）

> Dart 字符串是 UTF-16 编码的字符序列，可以使用单引号或双引号定义。

```dart
// 字符串定义
String name = "小明";

// 多行字符串
String str = '''This is a
multi-line
string.''';

// 字符串插值
String greeting = "Hello, $name!";
String info = "你好，${name} ！";

// 字符串连接
String combined = 'Hello ' + name;
```

### Booleans（布尔值）

> Dart 布尔类型只有两个值：`true` 和 `false`。

```dart
// 布尔值定义
bool isActive = true;
bool isCompleted = false;

// 布尔表达式
bool isAdult = age >= 18;
```

### Functions（函数）

> 函数是 Dart 中的一等公民，可以作为变量、参数和返回值使用。

```dart
// 函数定义：无返回值
void add2(int a, int b) {
  print(a + b);
}
// 函数定义：有返回值
int add3(int a, int b) {
  return a + b;
}
// 函数定义：箭头函数，自动推断返回值类型
var add4 = (int a, int b) => a + b;

/**
  * 函数定义：箭头函数，包含多行语句，需要用大括号括起来
  * 需要显式使用 return 关键字来指定返回值
  * 如果没有 return 语句，默认返回 Set<void>
  */ 
var add5 = (int a, int b) => {
  print(a + b);
};
```

### [List（列表）](常用数据类型操作.md)

> 列表是**有序**的对象集合，类似于其他语言中的数组。

```dart
// 不可变列表
const List a = [1,2,3]; 
const List<String> b = ['a','b','c']; // 显式指定泛型参数为 String

// 可变列表
List<int> c = [7,8];
List<String> d = ['Apple', 'Banana', 'Orange'];

c.add(9);
d[0] = 'Grape';

// 类型安全
List e = [1,2,3,'a','b','c']; // 未指定，没有指定泛型参数（类型不安全），推断为 List<dynamic>（可以存储任意类型的元素）。
List<String> f = ['a','b','c']; // 显式指定泛型参数为 String
```

### [Sets（集合）](常用数据类型操作.md)

> 集合是无序的**唯一**对象集合。

```dart
// 创建集合
Set<String> a = {'Alice', 'Bob', 'Charlie'};

// 添加元素
a.add('David');
a.add('Alice'); // 重复元素不会被添加

// 检查元素是否存在
bool b = a.contains('Alice');
```

### [Maps（映射）](常用数据类型操作.md)

> 映射是**键值对**的集合，类似于其他语言中的字典或哈希表。

```dart
// 创建映射
Map<String, int> ages = {'Alice': 25, 'Bob': 30, 'Charlie': 35};

// 添加或修改键值对，不能使用 ages.Bob 来访问
ages['David'] = 40;
ages['Alice'] = 26; 

// 获取值
int? aliceAge = ages['Alice']; // 可空类型变量
int unknownAge = ages['Unknown'] ?? 0; // 使用默认值

// 遍历映射
ages.forEach((key, value) {
  print('$key: $value');
});

// 获取键、值
ages.keys // 所有键：(Alice, Bob, Charlie)
ages.values // 所有值：(26, 30, 35)
```

### Records（记录）

> 记录是一种**不可变**、**复合**数据类型，用于将多个可能不同类型的值组合成一个单一对象，类似于元组（Tuple），但具有命名字段能力。

```dart
// 定义命名字段记录
var person = (name: 'Alice', age: 25, isActive: true); // 定义命名字段记录
({String name, int age, bool isActive}) person = (name: 'Alice', age: 25, isActive: true); // 类型注解
// 访问记录字段
print(person.name);     // 输出: Alice
print(person.age);      // 输出: 25
print(person.isActive); // 输出: true
person.age = 26; // 编译错误，记录创建后是完全不可变的，无法修改其任何字段：


// 位置字段记录
var user = ('Bob', 30, false); // 定义位置字段记录
(String, int, bool) user = ('Bob', 30, false); // 类型注解
// 访问记录
print(user.$1); // 输出: Bob
print(user.$2); // 输出: 30
print(user.$3); // 输出: false


// 混合模式
var mixed = ('Alice', age: 25, true);

// 解构位置字段
var user = ('Bob', 30, false);
var (firstName, _, isActive) = user; // 使用下划线忽略不需要的字段
print(firstName); // 输出: Bob

```

### Runes（符文）

> 符文是表示`Unicode`字符UTF-32编码点的类型，用于处理和操作`Unicode`字符，特别是那些超出基本多语言平面（`BMP`）的字符（如`emoji`表情符号）。

```dart
// 使用 \u{码点} 语法表示单个Unicode字符
String smiley = '\u{1F600}'; // 😀
String heart = '\u{2764}'; // ❤️
String rocket = '\u{1F680}'; // 🚀 (U+1F680)

// 获取字符串的 runes
Runes runes = smiley.runes;

// 遍历 runes
for (var rune in runes) {
  print(rune); // 输出 Unicode 码点
  print(String.fromCharCode(rune)); // 输出对应的字符
}

/**
  * 注意：
  * String.length 返回的是UTF-16代码单元的数量，而不是实际字符数
  * 使用 runes.length 可以获取实际的Unicode字符数量
  */

```

### Symbols（符号）

> 符号是Dart中程序**标识符**的特殊类型，用于在运行时引用变量名、函数名、类名等标识符，主要用于反射（`reflection`）和元编程。

```dart
// 创建符号
Symbol symbol1 = Symbol('myVariable');
Symbol symbol2 = #anotherVariable; // 简写语法

// 符号比较
bool isEqual = symbol1 == Symbol('myVariable'); // true

// 注意：Symbols主要用于 dart:mirrors 库中的反射操作，Flutter不支持此库
```

## 特殊类型

### 1. Null

> `Null` 类型只有一个值 `null`，表示空值。在空安全模式下，默认情况下变量不能为 null。

```dart
// 可空类型
String? nullableName;
nullableName = null; // 合法

// 非空类型
String nonNullableName = 'Alice';
nonNullableName = null; // 编译错误

// 空值检查
String name = nullableName ?? 'Unknown';
String anotherName = nullableName!; // 断言不为空，为空则抛出异常
```

### 2. dynamic

> `dynamic` 类型允许变量存储任何类型的值，关闭类型检查。

```dart
dynamic value = 42;
value = 'Hello'; // 合法
value = true; // 合法
```

### 3. var

>`var` 声明变量时，Dart 会根据初始值推断其类型。

```dart
var count = 42; // 推断为 int 类型
var name = 'Alice'; // 推断为 String 类型
var list = [1, 2, 3]; // 推断为 List<int> 类型
```

### 4. Object

>`Object` 是所有 Dart 对象的基类。

```dart
Object num = 42;
Object str = 'Hello';
```

### 5. void

>`void` 表示没有返回值的函数。

```dart
void printMessage(String message) {
  print(message);
}
```

### 6. Never

> `Never` 表示永远不会返回的函数，通常用于抛出异常或无限循环的函数。

```dart
Never throwError() {
  throw Exception('An error occurred');
}
```

## 类型系统特性

### 1. 静态类型

Dart 是静态类型语言，变量的类型在编译时确定。

```dart
String name = 'Alice'; // 明确指定类型
name = 42; // 编译错误，类型不匹配
```

### 2. 类型推断

Dart 可以根据上下文推断变量类型，无需显式声明。

```dart
var age = 30; // 推断为 int 类型
double area = 3.14 * 5 * 5; // 推断表达式结果为 double 类型
```

### 3. 空安全

Dart 2.12 引入了空安全特性，默认情况下变量不能为 null。

```dart
// 可空类型声明
int? nullableInt;
String? nullableString = null;

// 空值判断操作符
String name = nullableString ?? 'Default';
print(nullableString?.length); // 如果为 null 则返回 null，不会抛出异常
```

| 操作符 | 名称 | 描述 | 示例 |
|-------|------|------|------|
| `?` | 可空类型声明 | 声明一个变量可以为null | `String? name;` |
| `!` | 非空断言 | 断言变量不为null，如果为null会抛出异常 | `String nonNullName = nullableName!;` |
| `??` | null合并操作符 | 如果左侧表达式不为null，则返回其值；否则返回右侧表达式 | `String result = name ?? "Unknown";` |
| `??=` | null合并赋值操作符 | 如果变量为null，则将右侧表达式的值赋给它 | `name ??= "Default";` |
| `?.` | 条件成员访问 | 只有当对象不为null时，才会调用其成员 | `int? length = name?.length;` |
| `..?` | 条件级联 | 只有当对象不为null时，才会执行级联操作 | `person?..name = "Alice"..age = 30;` |
| `!` | 非空类型提升 | 在类型检查后提升可空类型为非空类型 | `if (name != null) { print(name!.length); }` |
| `<Type>?` | 可空泛型类型 | 声明泛型类型参数可以为null | `List<String?>? nullableList;` |
| `required` | 必填参数 | 标记构造函数或函数参数为必填 | `Person({required this.name});` |

## 类型转换

### 1. 隐式转换

Dart 不会自动进行某些类型转换，需要显式转换。

```dart
// 以下代码会导致编译错误
int i = 42;
double d = i; // 错误
```

### 2. 显式转换

```dart
// 数字类型转换
int i = 42;
double d = i.toDouble();

// 字符串转换
String intStr = i.toString();
String doubleStr = d.toStringAsFixed(2); // 保留2位小数

// 解析字符串为数字
int parsedInt = int.parse('42');
double parsedDouble = double.parse('3.14');

// 布尔值转换
String boolStr = true.toString();
```

## 类型检查和转换操作符

### 1. is 操作符

> 检查对象是否为指定类型。

```dart
void checkType(dynamic value) {
  if (value is int) {
    print('Value is an integer');
  } else if (value is String) {
    print('Value is a string');
  }
}
```

### 2. is!

> 检查对象是否不是指定类型。

```dart
if (value is! int) {
  print('Value is not an integer');
}
```

### 3. as 操作符

> 将对象转换为指定类型。

```dart
dynamic value = 'Hello';
String str = value as String;
```

## 类型别名

>类型别名允许为现有类型创建新名称，提高代码可读性。

```dart
// 为函数类型创建别名
typedef IntOperation = int Function(int, int);

// 使用别名
IntOperation add = (a, b) => a + b;
IntOperation multiply = (a, b) => a * b;

// 为复杂类型创建别名
typedef UserMap = Map<String, Map<String, dynamic>>;

// 使用别名
UserMap users = {
  'user1': {'name': 'Alice', 'age': 25},
  'user2': {'name': 'Bob', 'age': 30}
};
```

# 原始值

* 数字类型：`int`、`double`

* 布尔类型：`bool`

* 字符串类型：`String`

* 符号类型：`Symbol`

* 空类型：`Null`

# 引用值

* 集合类型：`List`、`Set`、`Map`

* 函数类型：`Function`

* 记录类型：`Record`

